import { db } from './firebaseConfig.js';
import {
    collection,
    addDoc,
    getDocs,
    query,
    where,
    orderBy,
    limit,
    doc,
    getDoc,
    updateDoc,
    setDoc,
    deleteDoc,
    Timestamp
} from "firebase/firestore";
import { v4 as uuidv4 } from 'uuid';

export interface ImageRecord {
    id: string; // Firestore ID usually, but we keep our UUID for compatibility
    userId: string;
    imageUrl: string;
    type: 'upload' | 'generated' | 'comic' | 'story' | 'animation';
    createdAt: string;
    prompt?: string;
    meta?: any;
    favorite?: boolean;
}

export interface UserRecord {
    uid: string;
    name: string;
    age?: number;
    gender?: 'Male' | 'Female' | 'Neutral';
    photoUrl?: string;
    points: number;
    createdAt: string;
    profileCompleted: boolean;
    password?: string;
    email?: string;
}

export interface PointsHistoryRecord {
    id: string;
    userId: string;
    delta: number;
    reason: string;
    createdAt: string;
}

export class DatabaseService {
    constructor() {
        console.log('[DatabaseService] Initialized with Firebase Firestore');
    }

    // --- Images ---
    public async saveImageRecord(
        userId: string,
        imageUrl: string,
        type: ImageRecord['type'],
        prompt?: string,
        meta?: any
    ): Promise<ImageRecord> {
        const newRecord: ImageRecord = {
            id: uuidv4(),
            userId,
            imageUrl,
            type,
            createdAt: new Date().toISOString(),
            prompt,
            meta: meta || {},
            favorite: false
        };

        try {
            // Using setDoc with ID to keep consistency or addDoc
            await addDoc(collection(db, "images"), newRecord);
            console.log(`[Database] Saved image record for user ${userId}: ${type}`);
        } catch (e) {
            console.error('[Database] Failed to save image:', e);
        }
        return newRecord;
    }

    public async getUserImages(userId: string): Promise<ImageRecord[]> {
        try {
            const q = query(
                collection(db, "images"),
                where("userId", "==", userId),
                orderBy("createdAt", "desc"),
                limit(50)
            );
            const snapshot = await getDocs(q);
            return snapshot.docs.map(d => {
                const data = d.data() as ImageRecord;
                return { ...data, id: d.id }; // Use Firestore ID or internal ID? Let's genericize
            });
        } catch (e) {
            console.error('[Database] Failed to get user images:', e);
            return [];
        }
    }

    // Since basic version was synchronous, we wrap this. 
    // Adapters will need to await this.
    // NOTE: The previous code was synchronous. We must check if callers await it.
    // I checked `media.ts`, it does NOT await `saveImageRecord` (fire and forget mostly).
    // `getUserImages` was synchronous in `router.get('/history')`. Wait, I need to check `media.ts`.

    public async toggleFavorite(id: string, userId: string): Promise<ImageRecord | null> {
        try {
            const q = query(collection(db, "images"), where("id", "==", id), where("userId", "==", userId)); // Assuming 'id' field is used
            // Or if we use Doc ID:
            // const docRef = doc(db, "images", id);

            // The previous implementation used UUIDs generated by the app.
            // We need to find the document with that UUID field.
            const snapshot = await getDocs(q);
            if (snapshot.empty) return null;

            const docRef = snapshot.docs[0].ref;
            const data = snapshot.docs[0].data() as ImageRecord;
            const newVal = !data.favorite;

            await updateDoc(docRef, { favorite: newVal });

            return { ...data, favorite: newVal };
        } catch (e) {
            console.error('[Database] Toggle fav failed:', e);
            return null;
        }
    }

    public async deleteImage(id: string, userId: string): Promise<boolean> {
        try {
            const q = query(collection(db, "images"), where("id", "==", id), where("userId", "==", userId));
            const snapshot = await getDocs(q);
            if (snapshot.empty) return false;

            await deleteDoc(snapshot.docs[0].ref);
            return true;
        } catch (e) {
            console.error('[Database] Delete failed:', e);
            return false;
        }
    }

    public async getPublicImages(): Promise<ImageRecord[]> {
        try {
            const q = query(collection(db, "images"), orderBy("createdAt", "desc"), limit(50));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(d => d.data() as ImageRecord);
        } catch (e) {
            console.error('[Database] Public images failed:', e);
            return [];
        }
    }

    // --- Users ---
    public async getUserProfile(uid: string): Promise<UserRecord | null> {
        try {
            const docRef = doc(db, "users", uid);
            const snap = await getDoc(docRef);
            if (snap.exists()) {
                return snap.data() as UserRecord;
            }
            return null;
        } catch (e) {
            console.error('[Database] Get user failed:', e);
            return null;
        }
    }

    public async updateUserProfile(uid: string, data: Partial<UserRecord>): Promise<UserRecord> {
        try {
            const docRef = doc(db, "users", uid);
            const snap = await getDoc(docRef);

            if (snap.exists()) {
                await updateDoc(docRef, data);
                return { ...snap.data(), ...data } as UserRecord;
            } else {
                const newUser: UserRecord = {
                    uid,
                    name: data.name || 'New Artist',
                    points: data.points || 0,
                    createdAt: new Date().toISOString(),
                    profileCompleted: data.profileCompleted || false,
                    email: data.email,
                    ...data
                } as UserRecord;
                await setDoc(docRef, newUser);
                return newUser;
            }
        } catch (e) {
            console.error('[Database] Update user failed:', e);
            throw e;
        }
    }

    public async getUserByEmail(email: string): Promise<UserRecord | null> {
        try {
            const q = query(collection(db, "users"), where("email", "==", email));
            const snapshot = await getDocs(q);
            if (snapshot.empty) return null;
            return snapshot.docs[0].data() as UserRecord;
        } catch (e) { return null; }
    }

    public async createUser(data: Partial<UserRecord> & { email: string; uid: string }): Promise<UserRecord> {
        return this.updateUserProfile(data.uid, data);
    }

    // --- Points ---
    public async awardPoints(userId: string, amount: number, reason: string): Promise<number> {
        try {
            const user = await this.getUserProfile(userId);
            let currentPoints = user ? user.points : 0;
            const newPoints = currentPoints + amount;

            await this.updateUserProfile(userId, { points: newPoints });

            await addDoc(collection(db, "points_history"), {
                id: uuidv4(),
                userId,
                delta: amount,
                reason,
                createdAt: new Date().toISOString()
            });

            console.log(`[Points] Awarded ${amount} to ${userId} for ${reason}. Total: ${newPoints}`);
            return newPoints;
        } catch (e) {
            console.error('[Database] Award points failed:', e);
            return 0;
        }
    }

    public async getPointsHistory(userId: string): Promise<PointsHistoryRecord[]> {
        try {
            const q = query(collection(db, "points_history"), where("userId", "==", userId), orderBy("createdAt", "desc"));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(d => d.data() as PointsHistoryRecord);
        } catch (e) { return []; }
    }
}

export const databaseService = new DatabaseService();
